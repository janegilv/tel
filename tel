#!/usr/bin/perl

use strict;
package Expect::Tel;
use Expect;
use Getopt::Std;
use Hash::Merge::Simple qw (merge);
use Module::Load;
use v5.10;
our $VERSION = eval '0.15';

__PACKAGE__->main() unless caller;

=head1 VERSION

0.15

=head1 AUTHOR

Robert Drake, C<< <rdrake at cpan.org> >>

=head1 COPYRIGHT & LICENSE

Copyright 2006 Robert Drake, all rights reserved.

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut


sub main {
    my $self = Expect::Tel->new();
    $self->{config} = load_config();

    my $opts;
    getopts('lx:c:t:', $opts);
    $self->{timeout} = $opts->{t} ? $opts->{t} : 90;
    $self->{opts} = $opts;

    for (@ARGV) {
        s#/tftpboot/##;
        s/-confg//;
        $self->login($_);
        if ($self->connected) {
            $self->conn($self->{'profile'}->{autocmds});
        }
    }
}

sub load_config {
    my $override = shift;
    my @configs = ( "/etc/telrc", "/usr/local/etc/telrc", "$ENV{HOME}/.telrc2", "$ENV{TELRC}" );
    @configs = qw ( $override ) if ($override);
    our $telrc;
    my $config;

    foreach my $conf (@configs) {
        if (-r $conf) {
            require $conf;
            push(@{$config->{'telrc_file'}}, $conf);
            $config = merge($config, $telrc);
        }
    }

    return $config;
}

sub new {
    my $has_keyring = 1;
    my $keyring;
    eval {
        load Passwd::Keyring::Auto;
        $keyring = get_keyring(app=>"tel script", group=>"Device Passwords");
        1;
    } or $has_keyring = 0;

    my $self = {
        'stdin' => Expect->exp_init(\*STDIN),
        'connected' => 0,
        'has_keyring' => $has_keyring,
        'keyring' => $keyring,
    };

    bless($self, 'Expect::Tel');
    return $self;
}

sub handle_backspace {
    ${$_[0]}->send("\b");
    return 1;
}

sub handle_ctrl_z {
    ${$_[0]}->send("exit\r");
    return 1;
}


# everything below here is a method.  Everything above is a function.
###################################################################################################################


sub send {
    return shift->{'session'}->send(@_);
}

sub expect {
    return shift->{'session'}->expect(@_);
}

# find the router by hostname/regex and load the config associated with it.
# Load a profile for it if there is one.
sub rtr_find {
    my $self = shift;
    my $host = shift;
    my $profile = $self->{'profile'};
    my $config = $self->{'config'};

    foreach my $h (@{$config->{rtr}}) {
        my $h2 = $h->{regex};
        if ($host =~ /$h2/i) {
            $profile=merge($profile, $h);
            last;
        }
    }
    $self->{'profile'}=$profile;

    if (defined($profile->{profile})) {
        return $self->profile($profile->{profile});
    }

    return $profile;
}

sub profile {
    my $self = shift;
    my $profile_arg = shift;
    my $replace = shift;
    my $stdin = $self->{'stdin'};
    my $config = $self->{'config'};
    my $session = $self->{'session'};
    my $profile = $self->{'profile'};

    return $profile if (!defined($profile_arg));

    if ($replace) {
        # wipe out the old profile if we're replacing it.
        $profile = {};
    }

    foreach(split(/\+/, $profile_arg)) {
        $profile = merge($profile, $config->{profile}{$_});
        if ($profile->{handlers}) {
            foreach my $v (keys %{$profile->{handlers}}) {
                $stdin->set_seq($v, $profile->{handlers}{$v}, [ \$self ]);
            }
        }
    }
    $self->{'profile'}=$profile;
    return $profile;
}

sub get_password {
    my $self = shift;
    my $profile = $self->profile;
    my $router = $profile->{real_hostname};

    # only use keyring if the password hasn't been found in our config files
    if ($profile->{password} ne '') {
        return $profile->{password};
    }

    if ($self->{has_keyring}) {
        my $password = $self->{keyring}->get_password($profile->{profile}, $router);
        if (!$password) {
            # ... somehow interactively prompt for password
            $self->{keyring}->set_password($profile->{profile}, $password, $router);
        }
    } else {
        return $profile->{password};
    }
}

# Expect won't let you reuse a connection that has spawned a process, so you
# can call this with an argument to reset the session.  If called without an
# argument it will return the current session (If it exists) or create a new
# session.
sub session {
    my $self = shift;
    my $renew = shift;

    return $self->{'session'} if (!$renew && defined($self->{'session'}));
    my $session = $self->{'session'};

    $session->soft_close() if ($session && $session->pid());
    $session = new Expect;

    # install sig handler for window size change
    $SIG{WINCH} = \&winch;

    sub winch {
        eval { $session->slave->clone_winsize_from(\*STDIN); };
        kill WINCH => $session->pid if $session->pid;
        $SIG{WINCH} = \&winch;
    }

    $session->log_stdout(1);
    $self->{'session'} = $session;
    return $session;
}


# this sets up the session.  If there already is a session open it closes and
# opens a new one.
sub connect {
    my $self = shift;
    my @arguments = shift;

    $self->connected(0);
    my $session = $self->session(1);
    $session->spawn(@arguments);
    return $session;
}

# connected, returns connection status.  Sets status if given input.
# this isn't the session state, but an indicator that our session has
# gotten through the login stage and is now waiting for input.

sub connected {
    my $self = shift;
    my $status = shift;
    if ($status) {
        $self->{connected}=$status;
    }

    return $self->{connected};
}

sub login {
    my $self = shift;
    my $hostname = shift;
    my $config = $self->{'config'};
    my $connected = 0;
    my @methods = qw ( ssh telnet );
    my $port;

    if ($hostname =~ /(\s+):(\d+)/) {
        # check for name:port, assume telnet if a port is specified and protocol is not
        $hostname = $1;
        $port = $2;
        @methods = ( "telnet" );
    }

    # default profile always loads before anything else.  Replace == 1
    $self->profile('default', 1);
    my $rtr = $self->rtr_find($hostname);

    # if hostname is defined as a method then call it to determine the real hostname
    # if it's not then treat it as an alias.
    if (defined($rtr->{hostname})) {
        if (ref($rtr->{hostname}) eq 'CODE') {
            $hostname = &{$rtr->{hostname}}($hostname);
        } else {
            $hostname = $rtr->{hostname};
        }
    }
    $rtr->{real_hostname}=$hostname;

    @methods = split(/,/, $rtr->{method}) if (defined($rtr->{method}));

    my $ssho = '-o StrictHostKeyChecking=no';
    if (defined($rtr->{sshoptions}) && scalar $rtr->{sshoptions} > 0) {
        my @sshoptions = @{$rtr->{sshoptions}};
        $ssho = '-o '. join(' -o ', @sshoptions);
    }

    my $allied_shit=0;
    # handle MOTD profile loading, and other things parsed from the config
    my @dynamic;
    foreach my $profile (keys %{$config->{banners}}) {
        push @dynamic, [ $profile, sub { $rtr = $self->profile($config->{banners}{$profile}); exp_continue; } ];
    }

    if (defined($rtr->{prompt})) {
        push @dynamic, [ qr/$rtr->{prompt}/, sub { $self->connected(1); last METHOD; } ];
    }

    METHOD: for (@methods) {
        my $cipher = '-c ' . $rtr->{ciphertype} if ($rtr->{ciphertype});

        $port ||= $rtr->{port};  # if port isn't set by the above hostname:port get it from the profile.
        # if it's not set in the profile or code above, it gets set in the
        # method below, but needs to be reset on each loop to change from
        # telnet to ssh defaults
        my $p = $port;

        if ($_ eq 'ssh')        { $p ||= 22; $self->connect("ssh -p $p -l $rtr->{user} $ssho $cipher $hostname"); }
        elsif ($_ eq 'telnet')  { $p ||= 23; $self->connect("telnet $hostname $p"); }
        # for testing. can pass an expect script to the other side and use it's output as our input.
        elsif ($_ eq 'exec')    { $self->connect($hostname); }
        else { die "No program defined for method $_\n"; }

        $self->expect($self->{timeout},
                @dynamic,
                # fucking shitty allied telesyn
                [ qr/User Access Verification - RADIUS/ => sub { $allied_shit=1;
                    $self->send("$rtr->{user}\r".$self->get_password()."\r"); exp_continue } ],
                [ qr/User Access Verification - Local/ => sub {
                    $self->send("$rtr->{user}\r".$self->get_password()."\r"); $self->connected(1); last METHOD; } ],
                [ qr/[Uu]ser[Nn]ame:|Login:/ => sub {
                    $self->send("$rtr->{user}\r") unless($allied_shit); exp_continue; } ],
                # we need to handle enable in a better way than this.  Enable
                # should support different password than regular if need be.
                [ qr/[Pp]ass[Ww]ord/ => sub {
                    if ($allied_shit) {
                        exp_continue;
                    } else {
                        $self->send($self->get_password() ."\r");
                        if ($rtr->{enablecmd}) {
                            $self->send($rtr->{enablecmd} . "\r".$self->get_password('enable')."\r");
                        }
                        $self->connected(1);
                        last METHOD;
                    }
                } ],
                [ qr/Name or service not known|hostname nor servname provided, or not known|could not resolve / => sub
                    {
                        # if host lookup fails then check to see if there is an alternate method defined
                        if ($rtr->{hostsearch} && !$rtr->{hostsearched}) {
                            $hostname = &{$rtr->{hostsearch}}($hostname);
                            $rtr->{hostsearched}=1;
                            redo METHOD;
                        } else {
                            warn "unknown host: $hostname\n";
                            # skip to next host if this one doesn't exist
                            last METHOD;
                       }
                    }
                ],
                [ qr/Corrupted/ => sub { next METHOD; } ],
                # almost never needed anymore.  Some people might not want a
                # fallback to des.  If anyone does we need to make it optional
                #[ qr/cipher type \S+ not supported/ => sub { $rtr->{ciphertype}="des"; redo METHOD; } ],
                [ qr/ssh_exchange_identification/ => sub { next METHOD; } ],
                [ qr/[Cc]onnection (refused|closed)/ => sub { next METHOD; } ],
                [ qr/key_verify failed/ => sub { next METHOD; } ],
                [ 'eof' => sub { next METHOD; } ],
                [ 'timeout' => sub { next METHOD; } ],
        );
    }

    if (!$self->connected) {
        warn "Connection to $hostname failed.\n";
        return;
    }

    $rtr->{logoutcmd} ||= "logout";
    $self->logging($hostname) if ($self->{opts}->{l});
}

sub logging {
    my $self = shift;
    my $router = shift;
    unlink ("/tmp/$router.log") if (-f "/tmp/$router.log");
    $self->session->log_file("/tmp/$router.log");
}

sub conn {
    my $self = shift;
    my $autocmds = shift;
    my $profile = $self->profile;
    my $opts = $self->{opts};
    my $prompt = $profile->{prompt};
    $prompt ||= '#';

    winch();

    my @args = split(/;/, $opts->{c});
    if ($opts->{x}) {
        open(X, '<', $opts->{x});
        @args = <X>;
        close X;
    }

    if (@args) {
        $self->expect(10,'-re',$prompt);
        $self->send("term len 0\r");
        $self->expect(10,'-re',$prompt);
        foreach my $arg (@args) {
            $self->send("$arg\r");
            $self->expect(10,'-re',$prompt);
        }
        $self->send($profile->{logoutcmd} ."\r");
    } else {
        $self->send("term len 0\r") if ($opts->{l});
        foreach my $arg (@{$autocmds}) {
            $self->send("$arg\r");
            $self->expect(10,'-re',$prompt);
        }
        $self->session->interact($self->{stdin}, '\cD');
        # q\b is to end anything that's at a More prompt or other dialog and
        # get you back to the command prompt
        $self->send("q\b" . $profile->{logoutcmd}. "\r");
    }
    $self->session->soft_close();
}

1;
