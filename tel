#!/usr/bin/perl

use strict;
package Local::Tel;
use Expect;
use Getopt::Std;
use Hash::Merge::Simple qw (merge);
use Module::Load;
use feature qw ( switch );

__PACKAGE__->main() unless caller;

sub main {
    my $self = Local::Tel->new();
    $self->{config} = load_config();

    my $opts;
    getopts('lx:c:t:', $opts);
    $self->{timeout} = $opts->{t} ? $opts->{t} : 90;
    $self->{opts} = $opts;

    # install sig handler for window size change
    $SIG{WINCH} = \&winch;

    sub winch {
        eval { $self->{session}->slave->clone_winsize_from(\*STDIN); };
        kill WINCH => $self->{session}->pid if $self->{session}->pid;
        $SIG{WINCH} = \&winch;
    }

    for (@ARGV) {
        s#/tftpboot/##;
        s/-confg//;
        $self->login($_);
    }
}

sub load_config {
    my @configs = ( "/etc/telrc", "/usr/local/etc/telrc", "$ENV{HOME}/.telrc2", "$ENV{TELRC}" );
    our $telrc;
    my $config;

    foreach my $conf (@configs) {
        if (-r $conf) {
            require $conf;
            push(@{$config->{'telrc_file'}}, $conf);
            $config = merge($config, $telrc);
        }
    }

    return $config;
}

sub new {
    $Expect::Log_Stdout=1;

    my $has_keyring = 1;
    my $keyring;
    eval {
        load Passwd::Keyring::Auto;
        $keyring = get_keyring(app=>"tel script", group=>"Device Passwords");
        1;
    } or $has_keyring = 0;

    my $self = {
        'session' => new Expect,
        'stdin' => Expect->exp_init(\*STDIN),
        'has_keyring' => $has_keyring,
        'keyring' => $keyring,
    };

    bless($self, 'Local::Tel');
    return $self;
}

# find the router by hostname/regex and load the config associated with it
sub rtr_find {
    my $self = shift;
    my $host = shift;
    my $profile = $self->{'profile'};
    my $config = $self->{'config'};

    foreach my $h (@{$config->{rtr}}) {
        my $h2 = $h->{regex};
        if ($host =~ /$h2/i) {
            $profile=merge($profile, $h);
            last;
        }
    }
    $self->{'profile'}=$profile;
}

sub load_profile {
    my $self = shift;
    my $profile = shift;
    my $replace = shift;
    my $stdin = $self->{'stdin'};
    my $config = $self->{'config'};
    my $session = $self->{'session'};
    my $rtr;
    if (!$replace) {
        $rtr = $self->{'profile'};
    }

    my @profiles = split(/\+/, $profile);
    foreach(@profiles) {
        $rtr = merge($rtr, $config->{profile}{$_});
        if ($rtr->{handlers}) {
            foreach my $v (keys %{$rtr->{handlers}}) {
                $stdin->set_seq($v, $rtr->{handlers}{$v}, [ \$session ]);
            }
        }
    }
    $self->{'profile'}=$rtr;
}

sub get_password {
    my $self = shift;
    my $rtr = $self->{profile};
    my $router = $rtr->{real_hostname};

    # only use keyring if the password hasn't been found in our config files
    if ($rtr->{password} ne '') {
        return $rtr->{password};
    }

    if ($self->{has_keyring}) {
        my $password = $self->{keyring}->get_password($rtr->{profile}, $router);
        if (!$password) {
            # ... somehow interactively prompt for password
            $self->{keyring}->set_password($rtr->{profile}, $password, $router);
        }
    } else {
        return $rtr->{password};
    }
}

sub login {
    my $self = shift;
    my $hostname = shift;
    my $config = $self->{'config'};
    my $session = $self->{'session'};
    my @methods = ( "ssh", "telnet" );
    my $connected = 0;
    my $port;  # undefined unless set on the CLI.  It will be overriden by load_profile or method defaults

    if ($hostname =~ /(\S+):(\d+)/) {
        # check for name:port, assume telnet if a port is specified and protocol is not
        $hostname = $1;
        $port = $2;
        @methods = ( "telnet" );
    }

    # default profile always loads before anything else.  Replace == 1 
    $self->load_profile('default', 1);
    $self->rtr_find($hostname);
    # this looks silly, but we're looking for a profile name that is set
    # inside the loaded profile we pulled out of rtr_find.
    $self->load_profile($self->{profile}->{profile}) if (defined($self->{profile}->{profile}));

    my $rtr = $self->{profile};

    # if hostname is defined as a method then call it to determine the real hostname
    # if it's not then treat it as an alias.
    if (defined($rtr->{hostname})) {
        if (ref($rtr->{hostname}) eq 'CODE') {
            $hostname = &{$rtr->{hostname}}($hostname);
        } else {
            $hostname = $rtr->{hostname};
        }
    }
    $rtr->{real_hostname}=$hostname;

    @methods = split(/,/, $rtr->{method}) if (defined($rtr->{method}));

    my $ssho = '-o StrictHostKeyChecking=no';
    if (defined($rtr->{sshoptions}) && $rtr->{sshoptions} > -1) {
        my @sshoptions = @{$rtr->{sshoptions}} if (defined($rtr->{sshoptions}));
        $ssho = '-o '. join(' -o ', @sshoptions);
    }

    my $allied_shit=0;
    # handle MOTD profile loading, and other things parsed from the config
    my @dynamic;
    foreach my $banner (keys %{$config->{banners}}) {
        push @dynamic, [ $banner, sub { $rtr = load_profile($rtr, $config->{banners}{$banner}); exp_continue; } ];
    }
    if (defined($rtr->{prompt})) {
        push @dynamic, [ qr/$rtr->{prompt}/, sub { $connected=1; last METHOD; } ];
    }

    METHOD: for (@methods) {
        my $cipher = '-c ' . $rtr->{ciphertype} if ($rtr->{ciphertype});
        $session->soft_close() if ($session->pid());
        $port ||= $rtr->{port};

        given ($_) {
            when ('ssh') { my $p=$port; $p ||= 22; $session->spawn("ssh -p $p -l $rtr->{user} $ssho $cipher $hostname"); }
            when ('telnet') { my $p=$port; $p ||= 23; $session->spawn("telnet $hostname $p"); }
            default { die "No program defined for method $_\n"; }
        }

        $session->expect($self->{timeout},
                @dynamic,
                # fucking shitty allied telesyn
                [ qr/User Access Verification - RADIUS/ => sub { $allied_shit=1;
                    $session->send("$rtr->{user}\r".$self->get_password()."\r"); exp_continue } ],
                [ qr/User Access Verification - Local/ => sub {
                    $session->send("$rtr->{user}\r".$self->get_password()."\r"); $connected=1; last METHOD; } ],
                [ qr/[Uu]ser[Nn]ame:|Login:/ => sub {
                    $session->send("$rtr->{user}\r") unless($allied_shit); exp_continue; } ],
                # we need to handle enable in a better way than this.  Enable
                # should support different password than regular if need be.
                [ qr/[Pp]ass[Ww]ord/ => sub {
                    if ($allied_shit) {
                        exp_continue;
                    } else {
                        $session->send($self->get_password() ."\r");
                        if ($rtr->{enablecmd}) {
                            $session->send($rtr->{enablecmd} . "\r".$self->get_password('enable')."\r");
                        }
                        $connected=1;
                        last METHOD;
                    }
                } ],
                [ qr/Name or service not known|hostname nor servname provided, or not known|could not resolve / => sub
                    {
                        # if host lookup fails then check to see if there is an alternate method defined
                        if ($rtr->{hostsearch} && !$rtr->{hostsearched}) {
                            $hostname = &{$rtr->{hostsearch}}($hostname);
                            $rtr->{hostsearched}=1;
                            redo METHOD;
                        } else {
                            warn "unknown host: $hostname\n";
                            # skip to next host if this one doesn't exist
                            last METHOD;
                       }
                    }
                ],
                [ qr/Corrupted/ => sub { next METHOD; } ],
                # almost never needed anymore.  Some people might not want a
                # fallback to des.  If anyone does we need to make it optional
                #[ qr/cipher type \S+ not supported/ => sub { $rtr->{ciphertype}="des"; redo METHOD; } ],
                [ qr/ssh_exchange_identification/ => sub { next METHOD; } ],
                [ qr/[Cc]onnection (refused|closed)/ => sub { next METHOD; } ],
                [ qr/key_verify failed/ => sub { next METHOD; } ],
                [ 'eof' => sub { next METHOD; } ],
                [ 'timeout' => sub { next METHOD; } ],
        );
    }

    if (!$connected) {
        warn "Connection to $hostname failed.\n";
        return;
    }

    $rtr->{logoutcmd} ||= "logout";
    $self->logging($hostname) if ($self->{opts}->{l});
    $self->conn($rtr->{autocmds});
}

sub logging {
    my $self = shift;
    my $router = shift;
    unlink ("/tmp/$router.log") if (-f "/tmp/$router.log");
    $self->{session}->log_file("/tmp/$router.log");
}


sub handle_backspace {
    ${$_[0]}->send("\b");
    return 1;
}

sub handle_ctrl_z {
    ${$_[0]}->send("exit\r");
    return 1;
}

sub conn {
    my $self = shift;
    my $autocmds = shift;
    my $session = $self->{session};
    my $rtr = $self->{profile};
    my $opts = $self->{opts};
    my $prompt = $rtr->{prompt};
    $prompt ||= '#';

    winch();

    my @args = split(/;/, $opts->{c});
    if ($opts->{x}) {
        open(X, '<', $opts->{x});
        @args = <X>;
        close X;
    }

    if (@args) {
        $session->expect(10,'-re',$prompt);
        $session->send("term len 0\r");
        $session->expect(10,'-re',$prompt);
        foreach my $arg (@args) {
            $session->send("$arg\r");
            $session->expect(10,'-re',$prompt);
        }
        $session->send($rtr->{logoutcmd} ."\r");
    } else {
        $session->send("term len 0\r") if ($opts->{l});
        foreach my $arg (@{$autocmds}) {
            $session->send("$arg\r");
            $session->expect(10,'-re',$prompt);
        }
        $session->interact($self->{stdin}, '\cD');
        # q\b is to end anything that's at a More prompt or other dialog and
        # get you back to the command prompt
        $session->send("q\b" . $rtr->{logoutcmd}. "\r");
    }
    $session->soft_close();
}

