#!/usr/bin/perl 

use strict;
use Expect;
use Getopt::Std;
use Hash::Merge::Simple qw (merge);
use Module::Load;
use feature qw ( switch );

my $has_keyring = 1;
my $keyring;
eval {
    load Passwd::Keyring::Auto;
    $keyring = get_keyring(app=>"tel script", group=>"Device Passwords");
    1;
} or $has_keyring = 0;



my $session = new Expect;
$Expect::Log_Stdout=1;
my $stdin = Expect->exp_init(\*STDIN);

my %opts;
getopts('lx:c:t:', \%opts);
my $timeout = $opts{t} ? $opts{t} : 90;
my $logoutcmd;


my @configs = ( "/etc/telrc", "/usr/local/etc/telrc", "$ENV{HOME}/.telrc2", "$ENV{TELRC}" );
our $telrc;
my $config;

foreach my $conf (@configs) {
    if (-r $conf) {
        require $conf;
        push(@{$config->{'telrc_file'}}, $conf);
        $config = merge($config, $telrc);
    }
}


# install sig handler for window size change
$SIG{WINCH} = \&winch;

sub winch {
    eval { $session->slave->clone_winsize_from(\*STDIN); };
    kill WINCH => $session->pid if $session->pid;
    $SIG{WINCH} = \&winch;
}


while(@ARGV) {
    my $router = shift;
    $router =~ s#/tftpboot/##;
    $router =~ s/-confg//;
    login($router);
}

sub rtr_find {
    my $host = shift;
    my $result = shift;

    foreach my $h (@{$config->{rtr}}) {
        my $h2 = $h->{regex};
        if ($host =~ /$h2/i) {
            $result=merge($result, $h);
            last;
        }
    }
    return $result;
}

sub load_profile {
    my $rtr = shift;
    my $profile = shift;
    if (!defined($profile)) {
        $profile = $rtr->{profile};
    }
    my @profiles = split(/\+/, $profile);
    foreach(@profiles) {
        $rtr = merge($rtr, $config->{profile}{$_});
        if ($rtr->{handlers}) {
            foreach my $v (keys %{$rtr->{handlers}}) {
                $stdin->set_seq($v, $rtr->{handlers}{$v}, [ \$session ]);
            }
        }
    }
    return $rtr;
}

sub get_password {
    my $rtr = shift;
    my $router = $rtr->{real_hostname};

    # only use keyring if the password hasn't been found in our config files
    if ($rtr->{password} ne '') {
        return $rtr->{password};
    }

    if ($has_keyring) {
        my $password = $keyring->get_password($rtr->{profile}, $router);
        if (!$password) {
            # ... somehow interactively prompt for password
            $keyring->set_password($rtr->{profile}, $password, $router);
        }
    } else {
        return $rtr->{password};
    }
}

sub login {
    my $router = shift;
    my @methods = ( "ssh", "telnet" );
    my $connected = 0;
    my $port;  # undefined unless set on the CLI.  It will be overriden by load_profile or method defaults

    if ($router =~ /(\S+):(\d+)/) {
        # check for name:port, assume telnet if a port is specified and protocol is not
        $router = $1;
        $port = $2;
        @methods = ( "telnet" );
    } 
   
    # default profile always loads before anything else
    my $rtr = load_profile(undef, 'default');  
    $rtr = rtr_find($router, $rtr);
    $rtr = load_profile($rtr) if (defined($rtr->{profile}));

    # if hostname is defined as a method then call it to determine the real hostname
    # if it's not then treat it as an alias.
    if (defined($rtr->{hostname})) {
        if (ref($rtr->{hostname}) eq 'CODE') {
            $router = &{$rtr->{hostname}}($router);
        } else {
            $router = $rtr->{hostname};
        }
    }
    $rtr->{real_hostname}=$router;

    @methods = split(/,/, $rtr->{method}) if (defined($rtr->{method}));
    
    my $ssho = '-o StrictHostKeyChecking=no';
    if (defined($rtr->{sshoptions}) && $rtr->{sshoptions} > -1) {
        my @sshoptions = @{$rtr->{sshoptions}} if (defined($rtr->{sshoptions}));
        $ssho = '-o '. join(' -o ', @sshoptions);
    }
   
    my $allied_shit=0;
    # handle MOTD profile loading, and other things parsed from the config
    my @dynamic;
    foreach my $banner (keys %{$config->{banners}}) {
        push @dynamic, [ $banner, sub { $rtr = load_profile($rtr, $config->{banners}{$banner}); exp_continue; } ];
    }
    if (defined($rtr->{prompt})) {
        push @dynamic, [ qr/$rtr->{prompt}/, sub { $connected=1; last METHOD; } ];
    }

    METHOD: for (@methods) { 
        my $cipher = '-c ' . $rtr->{ciphertype} if ($rtr->{ciphertype});
        $session->soft_close() if ($session->pid());
        $port ||= $rtr->{port};

        given ($_) {
            when ('ssh') { my $p=$port; $p ||= 22; $session = Expect->spawn("ssh -p $p -l $rtr->{user} $ssho $cipher $router"); }
            when ('telnet') { my $p=$port; $p ||= 23; $session = Expect->spawn("telnet $router $p"); }
            default { die "No program defined for method $_\n"; }
        } 

        $session->expect($timeout,
                @dynamic,
                # fucking shitty allied telesyn
                [ qr/User Access Verification - RADIUS/ => sub { $allied_shit=1;
                    $session->send("$rtr->{user}\r".get_password()."\r"); exp_continue } ],
                [ qr/User Access Verification - Local/ => sub { 
                    $session->send("$rtr->{user}\r".get_password()."\r"); $connected=1; last METHOD; } ],
                [ qr/[Uu]ser[Nn]ame:|Login:/ => sub {
                    $session->send("$rtr->{user}\r") unless($allied_shit); exp_continue; } ],
                # we need to handle enable in a better way than this.  Enable
                # should support different password than regular if need be.
                [ qr/[Pp]ass[Ww]ord/ => sub { 
                    if ($allied_shit) { 
                        exp_continue; 
                    } else {
                        $session->send(get_password($rtr) ."\r");
                        if ($rtr->{enablecmd}) {
                            $session->send($rtr->{enablecmd} .  "\r".get_password($rtr, 'enable')."\r");
                        }
                        $connected=1;    
                        last METHOD;
                    }
                } ],
                [ qr/Name or service not known|hostname nor servname provided, or not known|could not resolve / => sub
                    { 
                        # if host lookup fails then check to see if there is an alternate method defined
                        if ($rtr->{hostsearch} && !$rtr->{hostsearched}) {
                            $router = &{$rtr->{hostsearch}}($router);
                            $rtr->{hostsearched}=1;
                            redo METHOD;
                        } else {
                            warn "unknown host: $router\n";
                            # skip to next host if this one doesn't exist
                            last METHOD;
                       }
                    }
                ],
                [ qr/Corrupted/ => sub { next METHOD; } ],
                # almost never needed anymore.  Some people might not want a
                # fallback to des.  If anyone does we need to make it optional
                #[ qr/cipher type \S+ not supported/ => sub { $rtr->{ciphertype}="des"; redo METHOD; } ],
                [ qr/ssh_exchange_identification/ => sub { next METHOD; } ],
                [ qr/[Cc]onnection (refused|closed)/ => sub { next METHOD; } ],
                [ qr/key_verify failed/ => sub { next METHOD; } ],
                [ 'eof' => sub { next METHOD; } ],
                [ 'timeout' => sub { next METHOD; } ],
        );
    }

    if (!$connected) {
        warn "Connection to $router failed.\n";
        return;
    }

    $rtr->{logoutcmd} ||= "logout";
    logging($router) if ($opts{l});
    conn($rtr, $rtr->{autocmds});
}

sub logging {
    my $router = shift;
    unlink ("/tmp/$router.log") if (-f "/tmp/$router.log");
    $session->log_file("/tmp/$router.log");
}


sub handle_backspace {
    ${$_[0]}->send("\b");
    return 1;
}

sub handle_ctrl_z {
    ${$_[0]}->send("exit\r");
    return 1;
}

sub conn {
    my $rtr = shift;
    my $autocmds = shift;
    my $prompt = $rtr->{prompt};
    $prompt ||= '#';

    winch();

    my @args = split(/;/, $opts{c});
    if ($opts{x}) {
        open(X, '<', $opts{x});
        @args = <X>;
        close X;
    } 

    if (@args) {
        $session->expect(10,'-re',$prompt);
        $session->send("term len 0\r");
        $session->expect(10,'-re',$prompt);
        foreach my $arg (@args) {
            $session->send("$arg\r");
            $session->expect(10,'-re',$prompt);
        }
        $session->send($rtr->{logoutcmd} ."\r");
    } else {
        $session->send("term len 0\r") if ($opts{l});
        foreach my $arg (@{$autocmds}) {
            $session->send("$arg\r");
            $session->expect(10,'-re',$prompt);
        }
        $session->interact($stdin, '\cD');
        # q\b is to end anything that's at a More prompt or other dialog and
        # get you back to the command prompt
        $session->send("q\b" . $rtr->{logoutcmd}. "\r");
    }
    $session->soft_close();
}

